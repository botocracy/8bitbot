/*
 * Copyright (C) 2020 Marquise Stein
 * This file is part of 8bitbot - https://github.com/botocracy/8bitbot
 *
 * SPDX-License-Identifier: Apache-2.0
 * See LICENSE.txt for more information.
 */

import { Subject, Observable } from 'threads/observable';
import { expose, Transfer } from 'threads/worker';

import Module from '../../test/generated/stream_decoder.js';

// Streaming decoder
let decoder;

// Streaming worker results
let metadataAvailableSubject = new Subject();
let frameAvailableSubject = new Subject();
let videoEndedSubject = new Subject();

// Promise that is resolved when module runtime is initialized
let resolveInitialize;
let runtimeInitialized = new Promise((resolve, reject) => {
  resolveInitialize = resolve;
});

// Called when WASM module is initialized
Module.onRuntimeInitialized = (_) => {
  resolveInitialize();
};

// This method will be called when the runtime needs to load a file, such as
// a .wasm WebAssembly file, .mem memory init file, or a file generated by the
// file packager.
//
// The function receives the relative path to the file as configured in build
// process and a prefix (path to the main JavaScript fileâ€™s directory), and
// should return the actual URL.
Module['locateFile'] = function (path, prefix) {
  // Use the default, the prefix (JS file's dir) + the path
  return prefix + path;
};

const streamDecoder = {
  async initialize(fileName, blockSize, maxDecodedSize) {
    await runtimeInitialized;

    decoder = new Module.StreamDecoder(
      new TextEncoder('utf-8').encode(fileName),
      blockSize,
      maxDecodedSize
    );
  },

  async addPacket(packetBuffer, byteOffset, byteLength) {
    if (!decoder) {
      throw new Error('Stream decoder is not initialized');
    }

    const packetData = new Uint8ClampedArray(
      packetBuffer,
      byteOffset,
      byteLength
    );

    decoder.addPacket(packetData);
    const state = decoder.state;

    if (state == Module.StreamDecoderState.Failed) {
      return false;
    }

    return true;
  },

  async openVideo() {
    if (!decoder.openVideo()) return false;

    const frameSize = decoder.frameSize;
    const frameWidth = decoder.frameWidth;
    const frameHeight = decoder.frameHeight;

    metadataAvailableSubject.next({ frameSize, frameWidth, frameHeight });

    return true;
  },

  async decode() {
    while (true) {
      const state = decoder.state;

      switch (state) {
        case Module.StreamDecoderState.HasFrame:
          const frameData = decoder.getFrame();
          const frameSize = decoder.frameSize;

          // Get reference to WASM memory holding the frame
          var src = new Uint8ClampedArray(
            Module.HEAPU8.buffer,
            frameData,
            frameSize
          );

          // Allocate new pixel data
          const videoBuffer = new ArrayBuffer(frameSize);
          const dest = new Uint8Array(videoBuffer);

          // Copy pixels
          dest.set(src);

          frameAvailableSubject.next(Transfer(dest.buffer));
          return true;

        case Module.StreamDecoderState.Ended:
          onVideoEnded.next();
          return false;

        case Module.StreamDecoderState.Failed:
          throw new Error('Streaming decoder failed. See log for error');
      }

      decoder.decode();
    }
  },

  onMetadataAvailable() {
    return Observable.from(metadataAvailableSubject);
  },

  onFrameAvailable() {
    return Observable.from(frameAvailableSubject);
  },

  onVideoEnded() {
    return Observable.from(videoEndedSubject);
  },
};

expose(streamDecoder);
